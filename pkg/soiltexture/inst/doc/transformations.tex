\documentclass[a4paper]{article}

\title{Additional functions for transforming soil particle%%%
    size distributions}

\author{Wei Shangguan}



\RequirePackage{Sweave} 
 

%%% The commented parts below are needed by Sweave to index the vignette:
% \VignetteIndexEntry{transforming particle size distributions}
% \VignetteDepends{soiltexture} 
% \VignetteKeyword{soil} 
% \VignetteKeyword{texture} 
% \VignetteKeyword{plot} 
% \VignetteKeyword{classification} 
% \VignetteKeyword{transformation} 



\usepackage{Sweave}
\begin{document}



\maketitle



% +~~~~~~~~~~~~~~~~~~~~~~~~~~~~+
\section{Load the soiltexture package}


The soiltexture package can be installed from CRAN with the following 
commands: 

\begin{Schunk}
\begin{Sinput}
> install.packages("soiltexture") 
\end{Sinput}
\end{Schunk}


And loaded with the following commands:

\begin{Schunk}
\begin{Sinput}
> require( "soiltexture" ) 
> require( "drc" )
\end{Sinput}
\begin{Soutput}
'drc' has been loaded.

Please cite R and 'drc' if used for a publication,
for references type 'citation()' and 'citation('drc')'.
\end{Soutput}
\end{Schunk}



% +~~~~~~~~~~~~~~~~~~~~~~~~~~~~+
\section{Transforming soil texture data using many Particle-Size
Distribution models (from 3 or more particle size classes)}


\texttt{TT.text.\-transf.Xm()} is used to transform soil texture
data from 3 or more particle size classes using various
Particle-Size Distribution (PSD) models. The \texttt{drc} package
and its associate
packages(\texttt{lattice},\texttt{magic},\texttt{nlme},
\texttt{plotrix}) are required in the PSD model fitting.Compared to
\texttt{TT.text.\-transf()}, the following check is not needed (and
not done) :

\begin{itemize}
    \item When the 1st value of input \texttt{tri.data} and output
    particle size classes limits is 0, The 2nd value of the output
    particle size classes limits must be higher or equal to the
    2nd value of the input particle size classes limits."
\end{itemize}


We need first to create a dummy dataset with more than 3 particle
size classes:


\begin{Schunk}
\begin{Sinput}
> my.text4 <- data.frame(
+     "CLAY"  = c(05,60,15,05,25,05,25,45,65,75,13,47),
+     "FSILT" = c(02,04,10,15,25,40,35,20,10,05,10,20),
+     "CSILT" = c(03,04,05,10,30,45,30,25,05,10,07,23),
+     "SAND"  = c(90,32,70,70,20,10,10,10,20,10,70,10) 
+ )   #
\end{Sinput}
\end{Schunk}

Transform this data frame from 4 particle size classes to 3 particle
size classes:


\begin{Schunk}
\begin{Sinput}
> res <- TT.text.transf.Xm(
+     tri.data    = my.text4,
+     base.ps.lim = c(0,1,50,2000),
+     dat.ps.lim  = c(0,2,30,60,2000),
+     psdmodel    ="AD"
+ )   #
> #
> round( res[,1:6], 3 ) 
\end{Sinput}
\begin{Soutput}
         0-1   1-50 50-2000 f0:(Intercept) b:(Intercept) c:(Intercept)
 [1,]  4.334  4.655  91.011          0.594         0.371         4.125
 [2,] 59.657  6.931  33.412          0.807         0.148         3.211
 [3,] 13.544 14.967  71.489          0.837         0.534         1.242
 [4,]  3.409 23.471  73.120          0.571         0.412         1.630
 [5,] 24.119 49.476  26.408          0.619         0.265         4.298
 [6,]  4.432 81.452  14.127          0.520         0.318         9.165
 [7,] 24.380 62.014  13.626          0.620         0.256         6.735
 [8,] 44.516 41.643  13.851          0.721         0.189         5.926
 [9,] 63.849 14.739  21.411          0.833         0.171         1.102
[10,] 74.779 11.982  13.240          0.874         0.087         4.800
[11,] 11.933 15.829  72.239          0.611         0.361         1.988
[12,] 46.487 39.852  13.661          0.731         0.183         5.536
\end{Soutput}
\begin{Sinput}
> #
> round( res[,7:ncol(res)], 3 ) 
\end{Sinput}
\begin{Soutput}
      r0:(Intercept)   dev
 [1,]          0.678 0.822
 [2,]          0.138 0.000
 [3,]          1.115 0.006
 [4,]          0.179 0.000
 [5,]          0.039 0.000
 [6,]          0.032 0.000
 [7,]          0.031 0.002
 [8,]          0.035 0.000
 [9,]          0.090 0.000
[10,]          0.052 0.000
[11,]          0.231 0.000
[12,]          0.035 0.000
\end{Soutput}
\end{Schunk}



The first 3 columns are the predicted values with a sum not equal to
100\% (can be normalised by \texttt{TT.normalise.sum.X()}). The
following 4 columns are the fitted PSD model parameters. And the
last column is the Residual Sum of Squares (deviance). Note that the transforming 
results may be slightly different even with the same function parameters. 
This is cause by the nature of \texttt{drc} package in fitting dose-response models.\\\\

Sometimes, the fitting will failed for the iteration is not converged
or some errors and warnings happened. These can be ignored, as you
can get the transforming results.\\\\

The following PSD models are implemented: Anderson (AD), Fredlund4P
(F4P), Fredlund3P (F3P), modified logistic growth (ML),
Offset-Nonrenormalized Lognormal (ONL), Offset-Renormalized
Lognormal (ORL), Skaggs (S), van Genuchten type(VG),van Genuchten
modified, Weibull (W), Logarithm(L),  Logistic growth (LG),
Simple Lognormal (SL),Shiozawa and Compbell (SC). The performance of
PSD models is influenced by many aspects like soil texture class,
number and position (or closeness) of observation points, clay
content etc. The latter four PSD models perform worse than the
former ten. The AD, F4P, S, and W model is recommended for most of
texture classes. And it will be even better to compare several
different PSD models and using the results of the model with the
minimum residual sum of squares. Except S and W models, all the PSD
models could be used to predict the content below the minimum input
limit. The "psdmodel" option could be changed to any other of the
above models:


\begin{Schunk}
\begin{Sinput}
> res <- TT.text.transf.Xm(
+     tri.data    = my.text4,
+     base.ps.lim = c(0,1,50,2000),
+     dat.ps.lim  = c(0,2,30,60,2000),
+     psdmodel    = "ML"
+ )   #
> #
> round( res[,1:6], 3 ) 
\end{Sinput}
\begin{Soutput}
         0-1   1-50 50-2000 a:(Intercept) b:(Intercept) c:(Intercept)
 [1,]  4.944  3.944  91.113        19.463        13.360         1.014
 [2,] 59.849  6.848  33.302         0.675         5.740         0.983
 [3,] 14.721 13.805  70.984         6.473         4.911         0.549
 [4,]  4.413 22.512  72.510        53.883         7.420         0.304
 [5,] 24.467 46.833  28.701         3.162        62.766         1.140
 [6,]  4.376 76.266  19.359        26.148        57.095         0.834
 [7,] 24.185 58.851  16.964         3.259        72.585         1.090
 [8,] 44.788 38.541  16.671         1.238       180.310         1.534
 [9,] 64.027 14.559  21.322         0.615         4.400         0.564
[10,] 74.978 11.682  13.340         0.334       249.121         1.927
[11,] 12.405 15.397  71.925         8.172         5.553         0.527
[12,] 46.747 37.139  16.114         1.146       144.536         1.467
\end{Soutput}
\begin{Sinput}
> #
> round( res[,7:ncol(res)], 3 ) 
\end{Sinput}
\begin{Soutput}
 [1] 0.000 0.000 1.669 1.071 0.000 0.000 0.000 0.000 0.011 0.000 0.205 0.000
\end{Soutput}
\end{Schunk}

Because the current PSD model fitting is quite time-consuming and
some models are not always successful for all soils, you can change
the PSD model, or optimization method potentially at the cost of some accuracy.
The default "omethod" option (i.e. "all") is to run all methods and
choose the best results with minimum residual sum of squares. The
optional methods are "Nelder-Mead", "BFGS", "CG", "L-BFGS-B", "SANN"
(see \texttt{optim()} for details.)


\begin{Schunk}
\begin{Sinput}
> res <- TT.text.transf.Xm(
+     tri.data    = my.text4,
+     base.ps.lim = c(0,1,50,2000),
+     dat.ps.lim  = c(0,2,30,60,2000),
+     psdmodel    = "ML",
+     omethod     = "SANN"
+ )   #
> #
> round( res[,1:6], 3 ) 
\end{Sinput}
\begin{Soutput}
         0-1   1-50 50-2000 a:(Intercept) b:(Intercept) c:(Intercept)
 [1,]  4.845  4.085  91.070        20.051         9.774         0.892
 [2,] 59.849  6.848  33.302         0.675         5.739         0.983
 [3,] 14.721 13.805  70.984         6.473         4.910         0.549
 [4,]  4.414 22.511  72.512        53.828         7.420         0.304
 [5,] 24.468 46.829  28.703         3.161        62.777         1.140
 [6,]  4.419 76.229  19.352        25.810        57.513         0.838
 [7,] 24.185 58.852  16.963         3.259        72.582         1.090
 [8,] 44.789 38.541  16.670         1.238       180.353         1.534
 [9,] 64.027 14.559  21.322         0.615         4.400         0.564
[10,] 74.978 11.682  13.340         0.334       249.119         1.927
[11,] 12.405 15.399  71.920         8.174         5.550         0.526
[12,] 46.747 37.139  16.114         1.146       144.519         1.467
\end{Soutput}
\begin{Sinput}
> #
> round( res[,7:ncol(res)], 3 ) 
\end{Sinput}
\begin{Soutput}
 [1] 0.021 0.000 1.669 1.071 0.000 0.002 0.000 0.000 0.011 0.000 0.205 0.000
\end{Soutput}
\end{Schunk}



% +~~~~~~~~~~~~~~~~~~~~~~~~~~~~+
\section{Normalizing soil texture data (sum of X texture classes)}


\texttt{TT.normalise.sum.X()} is similar to 
\texttt{TT.normalise.sum()}. But it normalize the sum of the X (X>1)
texture classes instead of 3. The option \texttt{tri.data} should be
a data.frame with only soil texture data (no additional extra
columns should be present).



\begin{Schunk}
\begin{Sinput}
> my.text5 <- data.frame(
+     "CLAY"  = c(05,60,15,04.9,25,05,25,45,65,75,13,47),
+     "FSILT" = c(02,04.3,10,15,25,40,35,20,10,05,10,20),
+     "CSILT" = c(03,04,05,10,30,45,30,25,05,10,07.2,23.3),
+     "SAND"  = c(90.5,32,70,70,20.3,10.9,9.3,9.4,20,10,70,10)
+ )   #
> #
> res <- TT.normalise.sum.X( 
+     tri.data    = my.text5,
+     residuals   = TRUE
+ )   #
\end{Sinput}
\begin{Soutput}
 [1] 100.5 100.3 100.0  99.9 100.3 100.9  99.3  99.4 100.0 100.0 100.2 100.3
\end{Soutput}
\begin{Sinput}
> #
> res
\end{Sinput}
\begin{Soutput}
           CLAY     FSILT     CSILT      SAND residuals
 [1,]  4.975124  1.990050  2.985075 90.049751       0.5
 [2,] 59.820538  4.287139  3.988036 31.904287       0.3
 [3,] 15.000000 10.000000  5.000000 70.000000       0.0
 [4,]  4.904905 15.015015 10.010010 70.070070      -0.1
 [5,] 24.925224 24.925224 29.910269 20.239282       0.3
 [6,]  4.955401 39.643211 44.598612 10.802775       0.9
 [7,] 25.176234 35.246727 30.211480  9.365559      -0.7
 [8,] 45.271630 20.120724 25.150905  9.456740      -0.6
 [9,] 65.000000 10.000000  5.000000 20.000000       0.0
[10,] 75.000000  5.000000 10.000000 10.000000       0.0
[11,] 12.974052  9.980040  7.185629 69.860279       0.2
[12,] 46.859422 19.940179 23.230309  9.970090       0.3
\end{Soutput}
\end{Schunk}



\end{document}
